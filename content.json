[{"title":"正则分享","date":"2019-04-29T07:56:16.000Z","path":"2019/04/29/正则分享/","text":"正则表达式本次分享，帮助大家整体过一遍正则表达式的常用基础知识点，能够在以后的工作中，举一反三，不必害怕。 从最简单开始——尽可能严谨的给出匹配规则现在有一串坚果pro在微信下的useragent信息，通过大量的观察，可以发现，所有的坚果pro都有一个OD标识，且后面紧跟一串数字作为他的具体型号。1Mozilla/5.0 (Linux; U; Android 7.1.1; zh-CN; OD105 Build/NMF26F) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.108 UCBrowser/12.1.3.993 Mobile Safari/537.36 自然的，立刻想到了一个最简单的正则表达式/OD/。问题马上就来了，考虑如下正则1Mozilla/5.0 (iPOD; CPU iPhone OS 6_0_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A523 Safari/8536.25 使用/OD/竟然也测试通过了？但是这一条，是早期ipod toch的ua信息。为了避免类似的情况，我们的正则表达式至少应该写成这样/\\bOD\\d+/，其中\\b匹配一个单词的开头或者结尾（注：它是一个位置，不是单词和单词之间的空格），\\d代表数字，+代表出现的次数为至少出现1次。其中\\d\\、\\b和+，被称为元字符，其中+表示数量，有时候也被称之为限定符。接下来详细展开这2个类型。 元字符除了\\d\\和\\b，常用的元字符如下所示 元字符 说明 . 匹配除了换行符外任意字符 \\s 匹配任意的空白符 \\d 匹配数字 \\w 匹配字母、数字、下划线、汉字 \\b 匹配单词边界 ^ 匹配字符串的开始 $ 匹配字符串的结束 仍然以上面提到的useragent为例1Mozilla/5.0 (iPOD; CPU iPhone OS 6_0_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A523 Safari/8536.25 .匹配除了换行符的任意字符，如果没做全局匹配，则匹配结果为整个ua信息的首字母M，单独使用没啥意义 \\s匹配了ua信息中的空格，如果没做全局匹配，则匹配结果为Mozilla/5.0后面的空格 \\d匹配数字，上面有提过，如果没做全局匹配，匹配结果为5 \\w匹配字母、数字、下划线、汉字，如果没做全局匹配，匹配结果为M \\b匹配边界，一般是配合别的一起使用，比如\\bA，如果没做全局匹配，匹配结果为AppleWebKit的首字母A ^匹配字符串的开始，一般是配合别的一起用，比如^\\w，匹配结果为整个ua信息的首字母M $匹配字符串的结束，一般是配合别的一起用，比如\\w$，匹配结果为整个ua薪资的最后一个数字5 注： $和^都是为了写出更精准的匹配条件。 道理我都懂，看了不会用。举个栗子，判断一个串，是不是手机号 粗糙一点，\\d{11}，一个数字重复11次就行了。但是形如12345678987654321或者abc12345678987645sdf也会通过，怎么办？ 加个限制^\\d{11}$，一个数字重复11次，且必须是数字作为串的开头，数字作为串的结尾。但是01234567898也会通过，有0开头的手机号么？没有。 加个限制^1\\d{10}$，是不是好多了？到目前为止，我们先写到这里 限定符 限定符 说明 * 重复0次或者更多次 + 重复1次或者更多次 ? 重复0次或者1次 {n} 重复n次 {n,} 重复n次或者更多次 {n,m} 重复n到m次 限定符的使用比较简单，仍然以上面提到的useragent为例 1Mozilla/5.0 (iPOD; CPU iPhone OS 6_0_1 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10A523 Safari/8536.25 比如我们要提取ua中最后的Safari/8536.25，我们假定Safari/后面的数字是版本号，且小数点不是必须的。 最粗糙的，可以写Safari\\/\\d+但是小数点会被忽略 改造下，可以写Safari\\/\\d+\\.\\d+但是没小数点的就挂了 再改造下，可以写Safari\\/\\d+\\.?\\d* 同样的，如果确定是完整的一个串，且不与正文混合，Safari\\/\\d+\\.?\\d*，但是问题又来了，Safari/12.也能通过？ 原来，.和后面的数字，必须同时出现，所以Safari\\/\\d+(\\.\\d+)? 这样是不是好多了？ 转义你应该发现了，跟元字符一样的匹配，需要使用\\反斜杠来转义。比如我们刚刚Safari/8536.25中的/在匹配时，需要写为\\/，中间的小数点，在匹配时，也要写为\\.。其他元字符同理。 类和条件如果单独想匹配出数字、字母、空白等，有元字符已经可以直接帮助获取，有木有自己建立的集合呢？考虑我们刚刚所写的手机号匹配^1\\d{10}$，这里限制了第一位数，必须是1,那么，第二位数字是不是也可以限制下，保证匹配更加准确？目前已知的第二位有35678,我们可以使用[34678]来表示匹配其中的一个。更改后的正则为^1[34678]\\d{9}$，这样就准确多了。对于连贯性的数字或者字母，[]内甚至可以直接写[0-9]，等价于\\d，同样的，字母的匹配可以写[a-z][A-Z]，甚至可以组合使用[0-9a-zA-Z],如果再加上一个下划线，[0-9a-zA-Z_]，等价于\\w。但是，pm不要脸，换需求了pm要求，匹配15开头的号段，结尾必须是0，匹配13开头的号段，结尾必须是1。本能反应，我们噼里啪啦甩出去^1[35]\\d{8}[01]$，但不幸的是同样的，15开头的号段匹配了1结尾，13号段也匹配了0结尾。最粗糙的写法，^13\\d{8}[0]$|^15\\d{8}[1]$，看着像不像2个正则表达式给拼起来了？中间用了个 |分割了下？你会优化么？这里|即为正则表达式的条件。同样的场景，由于javascript内，对正则的支持有限，无法满足对括号的匹配，所以对于简单的括号情况，需要用条件语法去处理。但是，对于复杂的括号需求，还是建议使用递归，进行处理。 逆匹配上面，提到了常用的元字符，以及自定义的类，还有一种常用的需求，求一个类的倪匹配，比如，需要匹配除了数字以外，其他所有的情况。这时候需要用逆匹配来进行处理，规则非常简单： 元字符 说明 \\S 匹配任意的非空白符 \\D 匹配非数字 \\W 匹配非字母、非数字、非下划线、非汉字 \\B 匹配非单词边界 [^abc] 匹配非abc的其他所有 特殊的地方只有1处，就是对自定义类的逆匹配，需要一个[^]进行区分，常用的需求为，匹配一个xml标签，通常这么写&lt;[^\\s&gt;]+&gt;。 分组与引用对于分组，上面应该已经注意到，我们已经很顺其自然的写出了一个形如Safari\\/\\d+(\\.\\d+)?的正则，这里面的()即分组。分组非常有用，比如对单个字符的数量控制，可以使用限定符控制，对于一组字符串的处理，加个()就可以了。比如上面刚刚所写的(\\.\\d+)?就是小数点和数字在一个括号内，后面的限定符?，表示必须同时出现。对于分组，更多的应用场景，其实是引用。考虑一个需求，有一串电话号码&lt;010&gt;85600596，我们需要匹配他的区号，他的区号，都会以尖括号包括 粗糙的，我们写出了&lt;\\d{3,4}&gt;\\d{7,8}，因为区号有3-4位数，电话号码有7-8位数。但是这个正则在使用的时候，只能&#39;&lt;010&gt;85600596&#39;.match(/&lt;\\d{3,4}&gt;\\d{7,8}/)，怎么能在确认了是电话号码的情况下，拿到区号？ 增加分组&lt;(\\d{3,4})&gt;\\d{7,8}，这样，let res = &#39;&lt;010&gt;85600596&#39;.match(&lt;(\\d{3,4})&gt;\\d{7,8})就能在结果内，res[1]拿到我们的区号010。 对于引用，还有一种使用方式，叫向后引用。考虑一个字符串，&#39;abc&#39;，它的引号，有可能是&#39;也有可能是&quot;，做匹配怎么处理？ 仍然最粗糙的开始，写出了[&#39;&quot;][a-z]+[&#39;&quot;]，不幸的是，&#39;abc&quot;这样的字符串竟然也能通过。 这里考虑使用向后引用，([&#39;&quot;])[a-z]+\\1，考虑这里的\\1，意思是第一个分组。如果有多个括号，这个反斜杠的数字持续累加，对应的是从左到右的括号顺序，就是对应的分组。 为了加深印象，我们看下一个偏实际的需求： 123div &#123; background-image: url(&apos;https://a.com/b.png&apos;);&#125; 我们需要对background-image后面的url内容进行收集。但是，url的内容，可以是单引号，也可以是双引号。根据我们上面提到的知识点，很容易想到 首先可以得出url\\(([&#39;&quot;])([^\\s&#39;&quot;]+)\\1\\) 观察可以发现，引号可以单双，但是也可以完全不要引号，还记得上面提过的限定符么？url\\(([&#39;&quot;])?([^\\s&#39;&quot;]+)\\1\\) 不分组捕获和零宽断言为啥给这2个放到一起，因为他们的表达式很像，方便记忆。。首先看下不分组捕获，考虑上面提到的css内容123div &#123; background-image: url(&apos;https://a.com/b.png&apos;);&#125; 现在不但要考虑url的内容，还需要考虑background-image 粗糙的，background-image\\s*:\\s*url\\(([&#39;&quot;])?([^\\s&#39;&quot;]+)\\1\\)，因为冒号前后的空格个数，是随意的。 但是不难发现，在编写css时，会有连写属性，比如background: url(&#39;https://a.com/b.png&#39;)，-image并不是必须，所以正则改写为background(-image)?\\s*:\\s*url\\(([&#39;&quot;])?([^\\s&#39;&quot;]+)\\2\\) 问题来了，刚刚我们\\1的地方，现在改为了\\2，但是\\1并没有什么卵用，等于浪费了一个标号数字，怎么解决？ 不分组捕获的作用就来了，写法非常简单，(?:)即可。 修改后的正则background(?:-image)?\\s*:\\s*url\\(([&#39;&quot;])?([^\\s&#39;&quot;]+)\\1\\)，这样，虽然前面有一个括号，但是并没有给他赋予\\1的编号。 零宽断言的例子，其实，在开始的时候已经提过了。零宽，顾名思义，匹配的是个位置，而不是实际的内容，也就是说^、$、\\b都算是零宽断言。考虑更复杂的需求，还是开头的那一行useragent1Mozilla/5.0 (Linux; U; Android 7.1.1; zh-CN; OD105 Build/NMF26F) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.108 UCBrowser/12.1.3.993 Mobile Safari/537.36 我们分析发现，在OD105这个手机型号之前，总是有一个系统语言的标识，我们想得到他。 通过上面掌握的内容，可以轻松得到([\\w-]+);\\s*\\bOD\\d+\\b，这样分组\\1就是想要的内容。 有木有更优雅的方法？[\\w-]+(?=;\\s*\\bOD\\d+\\b)，注意这里的(?=)，代表的意思为零宽正预测先行断言，名字很屌，也相当拗口，只需记住，匹配以XXX为结尾的串，但是不捕获它，就ok了。 同样的，有正预测，就有负预测，负预测的意思就是，匹配不以XXX为结尾的串，但是不捕获它。应用场景也很常见，这里举一个简单的例子，已知一个生日，匹配不是9月1日生的人，是哪一年生的。 \\d{4}(?!0901)，(?!)的意思为零宽负预测先行断言。 有正也有负，有先行，必然也有后发，然而，后发断言javascript不支持，感兴趣的同学可以自己搜索下学习。总结下： 名称 语法 解释 不分组捕获 (?:exp) 匹配exp，但是不捕获，也不给分组，也没有组号 零宽正预测先行断言 (?=exp) 匹配exp前面的内容，单独使用没意义 零宽负预测先行断言 (?!exp) 匹配非exp前面的内容，单独使用没意义 贪婪与懒惰正常的限定符，都是贪婪匹配，有时候，我们会使用懒惰匹配，只需在限定符后面加?即可。举个栗子作为结束：a.*b，标识匹配a开头，b结尾的串 对于输入abbbbb，a.*b将为贪婪匹配到整个字符串，也就是说匹配结果是abbbbb 如果将限定符后面加上?得到a.*?b，则同样的输入，输出只会是ab 其他没聊到的以上基本上为web开发中大部分的应用场景，至于平衡组、递归匹配等高级内容，目前已知的只有.Net环境下支持，感兴趣的话可以自己搜索。 至于常用的正则学习方法，有2个网站供大家参考https://regexr.com/ 主要用来编写正则http://140.143.237.171/reg 用来可视化正则，方便找错玩的开心！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Regex","slug":"Regex","permalink":"http://yoursite.com/tags/Regex/"}]},{"title":"Promise","date":"2019-01-28T03:29:32.000Z","path":"2019/01/28/Promise/","text":"一、最简单Promnise根据定义可知，promise是一个规范，规范并不在意promise是怎样create、reject，fulfill。规范只在意有木有一个then方法。根据我们下面的使用方式123456789let p = new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(100); &#125;, 5000);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 可以清楚的感知到，我们传入了个函数，这个函数会在内部执行。同时，then方法会注册一个回调，该回调在resolve后进行执行，并且拿到resolve的传参。那么，我们的promise可以简单定义为：12345678910111213141516171819202122232425262728293031323334353637383940414243function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; self.onFulfilled = null; self.onRejected = null; function resolve(value) &#123; self.value = value; self.onFulfilled(value); &#125; function reject(reason) &#123; self.reason = reason; self.onRejected(reason); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; this.onFulfilled = onFulfilled; this.onRejected = onRejected;&#125;let p = new MyPromise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(100); &#125;, 5000);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 二、不异步行不行要知道我们正常使用Promise传入的函数，可以是异步函数，可以是同步函数。但是，当我们试着给setTimeout干掉之后，会发现报错。1234567let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 具体的错误发生在上面的resolve定义的地方1234function resolve(value) &#123; self.value = value; self.onFulfilled(value);&#125; 因为resolve执行的时候，then注册的回调函数还没有挂载在self.onFulfilled上。解决办法很简单，只需将resolve方法的主体，使用setTimeout包裹即可。reject同理。则上面的最简单的MyPromise就变成了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; self.onFulfilled = null; self.onRejected = null; function resolve(value) &#123; // 包个setTimeout setTimeout(() =&gt; &#123; self.value = value; self.onFulfilled(value); &#125;); &#125; function reject(reason) &#123; // 包个setTimeout setTimeout(() =&gt; &#123; self.reason = reason; self.onRejected(reason); &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; this.onFulfilled = onFulfilled; this.onRejected = onRejected;&#125;let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 三、状态我们都知道，每个promise具有3个状态。pending、fulfilled、rejected。在pending状态下可以分别向其他状态转换，而且fulfilled、rejected的状态不能改变。那么，MyPromise可以如下表示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; // 加个状态 self.status = 'pending'; self.onFulfilled = null; self.onRejected = null; function resolve(value) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; // 改变状态 self.status = 'fulfilled'; self.value = value; self.onFulfilled(value); &#125;); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; // 改变状态 self.status = 'rejected'; self.reason = reason; self.onRejected(reason); &#125;); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; // 如果是pending，则注册 this.onFulfilled = onFulfilled; this.onRejected = onRejected; &#125; else if (this.status === 'fulfilled') &#123; // 如果是fulfilled则直接执行 onFulfilled(); &#125; else if (this.status === 'rejected') &#123; // 如果是rejected则直接执行 onRejected(); &#125;&#125;let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;); 四、链式操作目前来看，只能使用一个then，要想使用promise.then(func1).then(func2).then(func3)这种操作，还需要对回调函数的注册进行一番改造。操作起来非常简单，只需在全局注册2个数组用来存放回调函数，在pending时push，在resolve时遍历回调数组，并挨个调用即可。这里需要谨记，在函数主体（后面简称main）执行的时候，then接收的参数，理论上应该是一个函数，如果不是函数，后续我们的MyPromise会做一些容错处理。main执行到then，会将then内的参数（函数）挂起，到下一轮事件循环时候再去执行。对这里不太清楚的小伙伴可以了解下microtask和macrotask。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function MyPromise(executor) &#123; let self = this; self.value = undefined; self.reason = undefined; self.status = 'pending'; // 变成数组 self.onFulfilledCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; self.status = 'fulfilled'; self.value = value; // 遍历回调数组，并调用 self.onFulfilledCallbacks.forEach(callback =&gt; &#123; callback(self.value); &#125;); &#125;); &#125; &#125; function reject(reason) &#123; if (self.status === 'pending') &#123; setTimeout(() =&gt; &#123; self.status = 'rejected'; self.reason = reason; // 遍历循环数组，并调用 self.onRejectedCallbacks.forEach(callback =&gt; &#123; callback(self.value); &#125;); &#125;); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; console.log(e); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; this.onFulfilledCallbacks.push(onFulfilled); this.onRejectedCallbacks.push(onRejected); &#125; else if (this.status === 'fulfilled') &#123; onFulfilled(); &#125; else if (this.status === 'rejected') &#123; onRejected(); &#125; // 返回自己，才能链式操作 return this;&#125;let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; console.log(data);&#125;).then(function (data) &#123; console.log(data);&#125;); 上述代码看起来没啥问题，但是在诸如以下使用时，12345678910let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; setTimeout(() =&gt; &#123; console.log(data + 1); &#125;, 100);&#125;).then(function (data) &#123; console.log(data);&#125;); 会打印100 101。也就是说，第二个then先执行了。而且data的值，由于读的是同一个promise实例的data，在resolve的时候，也写死了，没有办法继续透传改变。要想实现每一个then都读上一个then的value，我们立刻可以想到，then应该返回一个新的promise，他拥有自己的data，这样一级一级往下传递，就实现了真正的异步串行操作。 五、then的改造回到上一节最后抛出的问题，上面的所有步骤，then中都直接返回了this，但是，问题来了，我们的需求为：每次调用then传参，取决于上一个then回调的返回值。看下面片段123456789101112131415161718MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; if (self.status === 'fulfilled') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; &#125;) &#125; else if (self.status === 'rejected') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; &#125;) &#125; else if (self.status === 'pending') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; &#125;) &#125;&#125; 可以看到，then中当前（对，当前，看清楚，我是说当前）的promise有3个状态，我们分别返回一个新的（新的，我new了，new了之后，下一级then内的this会变）promise。 另外考虑如下使用方式：12345678let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; return data + 200&#125;).then(function (data) &#123; console.log(data);&#125;); 我们希望最后的console.log(data)的结果是300，那么，在then的内部，promise2应该先拿到上一个MyPromise的值（也就是onFulfilled或者onRejected的值），然后马上resolve掉这个内部的promise。注意，这个resolve是为了传递内部的promise，也就是promise2的值，所以不管什么情况，最后只管resolve就是了。1234567891011121314151617181920212223242526272829303132333435363738394041424344MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; if (self.status === 'fulfilled') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onFulfilled(self.data); resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125; else if (self.status === 'rejected') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onRejected(self.data); resolve(x); &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125; else if (self.status === 'pending') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; // 如果是`pending`状态，则一样只需给当前的数组压入回调即可 self.onFulfilledCallbacks.push((value) =&gt; &#123; try &#123; let x = onFulfilled(value); resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push((reason) =&gt; &#123; try &#123; let x = onRejected(reason); resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125; 到目前为止，看似都很美好。但是如果onFulfilled返回的x是一个新的MyPromise呢？所以，在Promise2中，不能简单的resolve这个promise2。我们这里定义个函数，用来专门处理x的值。123456789101112131415161718// 这里传入4个参数，x为promise2的onFulfilled或者onRejected的值，resolve和reject就是promise2的2个实参，至于为啥传递个`promise2`进来，后面我们慢慢完善，就发现他的作用了，这里暂时不管。function resolvePromise(promise2, x, resolve, reject) &#123; if (x instanceof MyPromise) &#123; // 如果x是promise的实例，则需要分类讨论是否pending if (x.status === 'pending') &#123; // 如果promise仍然是pending，则注册这个promise的回调函数，继续递归，直到返回值不是pending的promise为止 x.then(value =&gt; &#123; resolvePromise(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; // 如果promise以及被决断，则肯定有个resolve或者reject的值，直接调用then，拿到promise的最终值即可 x.then(resolve, reject); &#125; &#125; else &#123; // 如果x不是promise，直接resolve，降级为上面的x值非promise的情况 resolve(x); &#125;&#125; 这个函数是整个MyPromise中最抽象的地方。我们先分类讨论它的情况。 如果x的值不是MyPromise的实例，问题降级为上面x非promise的情况。 如果x的值是MyPromise的实例，但是状态已经被fulfilled或者rejected，则x肯定有一个最终的value，我们只需继续x.then(reolve, reject)，拿到x这个MyPromise的最终值即可。 如果x的值是MyPromise的实例，但是状态仍然是pending，我们同样需要调用then函数（promise每一步只能去then），去注册这个x的回调函数（再次啰嗦，x是MyPromise实例），继续递归，直到返回值不是pending状态的MyPromise为止。 至此，我们的MyPromise基本可用了，贴一下then方法此时的样子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this; let promise2; if (self.status === 'fulfilled') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onFulfilled(self.data); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125; else if (self.status === 'rejected') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; try &#123; let x = onRejected(self.data); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e) &#125; &#125;); &#125; else if (self.status === 'pending') &#123; return promise2 = new MyPromise(function (resolve, reject) &#123; // 如果是`pending`状态，则一样只需给当前的数组压入回调即可 self.onFulfilledCallbacks.push((value) =&gt; &#123; try &#123; let x = onFulfilled(value); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push((reason) =&gt; &#123; try &#123; let x = onRejected(reason); // 替换 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125;&#125; 组装完成后，配合下面的demo，可以查看 123456789101112let p = new MyPromise(function (resolve, reject) &#123; resolve(100);&#125;);p.then(function (data) &#123; return new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(data + 100); &#125;, 2000); &#125;);&#125;).then(function (data) &#123; console.log(data);&#125;); 基本的Promise以及实现了，但是仍然有很多细节，我们慢慢补充。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"自适应照片墙布局","date":"2018-04-11T07:15:32.000Z","path":"2018/04/11/自适应照片墙布局/","text":"最近，业务上对照片处理的需求比较多，其中有一个照片瀑布流的效果，类似于500px，实现图片自适应的等高、无拉伸、无剪裁显示。大概效果如下图所示。 开始以为会有点好玩的算法，通过js简单控制图片的排列，后来发现，在已知每幅图的宽高的情况下，只需css即可实现这样的效果。 核心代码如下所示： 1234567&lt;div id=\"app\"&gt; &lt;div class=\"img-wrap\" v-for=\"item in imgs\" :style=\"`width: $&#123;item.width/item.height * 100&#125;px; flex-grow: $&#123;item.width/item.height * 100&#125;`\"&gt; &lt;i :style=\"`padding-bottom: $&#123;item.height/item.width * 100&#125;%`\"&gt;&lt;/i&gt; &lt;img :src=\"item.url\"&gt; &lt;/div&gt;&lt;/div&gt; 其中css为 1234567891011121314151617#app &#123; display: flex; flex-wrap: wrap;&#125;.img-wrap &#123; margin: 2px; background-color: violet; position: relative;&#125;i &#123; display: block;&#125;img &#123; position: absolute; top: 0; width: 100%;&#125; 接下来是原理。 首先高度要一致首先，看下最后的实现结果可以知道，每一行的高度要求持平，也就是说，在同一行中，所有图片的高度要求缩放到一致。那么，我们不妨设某一行的图片高度为100px。此时，该行图片中的某一张的已知真实宽高分别为w和h。此时，如果将h缩放至100px，那么可以知道，该图片的宽度应该为100w/h。也就是说，此时，承载这张图片的容器的样式应为 123&lt;div class=\"img-wrap\" v-for=\"item in imgs\" :style=\"`width: $&#123;item.width/item.height * 100&#125;px;\"&gt;&lt;/div&gt; 其次子元素撑开图片容器这里先提一下，当padding以及margin的值为百分比的时候，其实是相对于父级width的。也就是说，在业务中，很多情况下一些自适应的正方形块，我们可以通过子元素padding-bottom: 100%，意思是高度是父元素宽度的100%，这样就将父级元素撑成一个正方形。 而此时，并不是所有图片都是正方形，但是，我们已知图片的原有宽高，那么宽高的比例也是已知的，分别为w和h，那么也就是说，高度h是宽度w的h/w %。也就是说，我们只需将一个子元素的padding-bottom设置为h/w %，即可得到一个满足图片的原有比例图片容器。那么，此时图片的容器样式应该为 123&lt;div class=\"img-wrap\" v-for=\"item in imgs\" :style=\"`width: $&#123;item.width/item.height * 100&#125;px;\"&gt; &lt;i :style=\"`padding-bottom: $&#123;item.height/item.width * 100&#125;%`\"&gt;&lt;/i&gt;&lt;/div&gt; 那么这时候就会问了，开始咱们不是定了高度为100px么？ 最后两端对齐再看一眼我们最终要实现的结果，不但要求底部水平对齐，还要求两端对齐。用过flex就知道，只需将父元素设置为display: flex，子元素设置flex-grow: x即可。这时，x应该是多少呢？要知道，flex-grow是按照此比例，分配剩余的空间。又因为每个图片的大小是不一样的，所以，这个flex-grow的值当然是不一样的。细心的我们可以发现，其实比例，只需按照自身的宽度分配即可，也就是说，flex-grow：w/h*100，正所谓，胖子多得。。 那么问题就来了，宽度已经被flex-grow了，那么高度怎么办？高度还是100px么？显然不是了，但是看下上一小节中，我们对子元素的处理，用来撑开图片容器的子元素&lt;i&gt;的高度，也就是它的padding-bottom，是根据图片容器的宽度自适应的！那么，上一节的最后个疑问是不是已经打消了？ 换行换行就比较简单了，父元素设置flex-wrap: wrap即可。最终的代码完全体，就和开始一样。 最后回想开始的时候，我们假设的高度100px，这个值是可以根据自身的需要去简单调整的，这个初始值确定了之后，后续的flex-grow会在100px左右伸缩。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"React原理（四）setState","date":"2018-03-25T13:14:50.000Z","path":"2018/03/25/React原理（四）setState/","text":"在这一节中，我们将给Feact增加setState方法，这个方法非常有趣，端起饮料好好享受吧。 给Feact添加statestate和props非常相似，他们都是组件在渲染的时候，流动在内部的数据。不同的是props来自于外部，state是内部的。到目前为止，Feact只支持props，所以，在我们搞出setState之前，我们得先给这个小框架增加个state这个概念。 getInitialState当我们挂载一个新组件的时候，我们需要给这个组件增加一个初始state，这个时候，我们需要调用getInitialState这个生命周期函数。该生命周期函数需要在实例化的时候被调用，所以，我们需要在Feact.createClass构造函数里增加钩子。 123456789101112131415const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; const initialState = this.getInitialState ? this.getInitialState : null; this.state = initialState; &#125; Constructor.prototype = Object.assign(Constructor.prototype, spec); return Constructor; &#125;&#125; 就像props一样，我们给组件实例增加state、 注意，当我们组件没有getInitialState定义的时候，state的初始状态是null，React不会给state添加默认值为空对象。所以，当想使用state的时候，必须利用这个方法，返回一个对象。否则，如果在使用this.state.foo这样的操作的时候，第一次render会爆炸的哦。 现在，有了getInitialState，Feact组件可以随时使用this.state这个方法啦。 增加简单的setState()现在，我们准备给setState在Feact.createClass中，找一个合适的位置。为了实现它，我们将给所有的通过Feact.createClass创建的组件一个prototype，这个prototype将拥有一个setState方法。 123456789101112131415161718192021222324252627282930313233function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function () &#123; // TODO&#125;function mixSpecIntoComponent(Constructor, spec) &#123; const proto = Constructor.prototype; for (const key in spec) &#123; proto[key] = spec[key]; &#125;&#125;const Feact = &#123; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; const initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; &#125; Constructor.prototype = new FeactComponent(); mixSpecIntoComponent(Constructor, spec); return Constructor; &#125;&#125; misSpecIntoComponent在React中，那可是相当的复杂，当然，也更健壮，它的角色更像是mixins，同时，保证用户在使用的时候，不会因为这个函数翻车。 让setState代入到updateComponent方法中回顾上一节，我们通过FeactCompositeComponentWrapper.receiveComponent来实现一个组件的更新，而这个函数接下来调用了updateComponent方法，所以，看起来我们只要通过updateComponent来处理state就能实现更新。那么，我们只需要将FeactComponent.prototype.setState和FeactCompositeComponentWrapper.receiveComponent打通即可。 在React中，有『公共实例』和『内部实例』的概念。公共实例是通过createClass创建的组件的实例，内部实例是React内部对象的实例。那么，在这些概念下，内部实例就是FeactCompositeComponentWrapper，不难发现，内部实例能够感知到公共实例的一切，但是反过来却不行。现在，我们准备改变这个。setState是公共实例给内部实例通信的方法，带着这个想法，看如下实现 1234567891011function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function (partialState) &#123; const internalInstance = getMyInternalInstancePlease(this); internalInstance._pendingPartialState = partialState; FeactReconciler.performUpdateIfNecessary(internalInstance);&#125; React解决getMyInternalInstancePlease这个问题的方法是通过一个实例映射，这个映射保存了某个公共实例内的内部实例。 123456789const FeactInstanceMap = &#123; set(key, value) &#123; key.__feactInternalInstance = value; &#125;, get(key) &#123; return key.__feactInternalInstance; &#125;&#125; 而这个映射关系的建立，是在组件挂载的时候。 12345678910111213const FeactCompositeComponentWrapper &#123; // 其他都一样 mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; FeactInstanceMap.set(componentInstance, this); &#125;&#125; 现在，还有一个没有用到的方法，FeactReconciler.performUpdateIfNecessary，这个方法就像其他的协调器方法一样 12345678910111213141516const FeactReconciler &#123; // 其他都一样 performUpdateIfNecessary(internalInstance) &#123; internalInstance.performUpdateIfNecessary(); &#125;&#125;class FeactCompositeComponentWrapper &#123; // 其他都一样 performUpdateIfNecessary() &#123; // 注意这里，一样哦 this.updateComponent(this._currentElement, this._currentElement); &#125;&#125; 最终，我们终于调用了updateComponent，但是请注意，这里我们做了一点HACK，虽然我们调用了更新，但是，我们传递了相同的两个参数。任何时候，当updateComponet传递了相同的元素，React就知道，只有state更新了，否则就是props更新了。React会通过prevElement !== nextElement来判断是否调用componentWillReceiveProps，所以，这里先改造下Feact，让它也做相同的处理。 123456789101112131415class FeactCompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; const willReceive = prevElement !== nextElement; if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; // 其他都一样 &#125;&#125; 这个只是updateComponent的片段，只是为了解决setState()并不会导致componentWillReceiveProps在渲染前的调用。也就是说，setState无需影响到props。 通过新的state更新现在处理updateCompoent，内部实例已经通过internalInstance._pendingPartialState获取到了新的state，所以现在我们需要做的，仅仅是让这个组件再渲染一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FeactCompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; const willReceive = prevElement !== nextElement; if (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; let shouldUpdate = true; const nextState = Object.assignn(&#123;&#125;, inst.state, this._pendingPartialState); this._pendingPartialState = null; if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState); &#125; if (shouldUpdate) &#123; this._performComponentUpdate(nextElement, nextProps, nextState); &#125; else &#123; inst.props = nextProps; inst.state = nextState; &#125; &#125; _performComponentUpdate(nextElement, nextProps, nextState) &#123; this._currentElement = nextElement; const inst = this._instance; inst.props = nextProps; inst.state = nextState; this._updateRenderedComponent(); &#125; _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); FeactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement ); &#125;&#125; 组件的更新跟之前很像，不同的是，我们增加了state的赋值操作。因为state仅仅挂载在公共实例上，_performComponentUpdate只改变了一行，_updateRenderedComponent一行没变。真正改变的重点就是在updateComponent中，我们合并state的操作。 至此，setState的功能，已经基本完成啦！ 但是，上面的setState的实现，比较屌丝，性能也比较糟糕。主要的问题是，每次调用setState都会导致组件的渲染。这将迫使用户，要么好好想想怎么组装数据然后只使用一次setState，要么就接受这种每次调用就渲染的问题。接下来，我们要做的就是改造它，使它最好能自适应的具有批量工作的能力，从而减少渲染的次数。 批量调用setState仔细观察生命周期函数的调用，不难发现，每次的渲染，都调用了componentWillReceiveProps。如果用户在componentWillReceiveProps中调用setState会发生什么？在当前的代码中，这将会导致在第一次渲染过程中又一次新的渲染，而对state改版而造成的props的响应，画面太美不敢看。所以，我们最好将一系列的state和props的改变，都塞到同一次渲染中。 首先我们需要给需要批量的操作保存起来首先想到的就是改造_pendingPartialState，让它成为一个数组。 123456789101112function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function (partialState) &#123; const internalInstance = FeactInstanceMap.get(this); internalInstance._pendingPartialState = internalInstance._pendingPartialState || []; internalInstance._pendingPartialState.push(partialState); // 其他都一样&#125; 而在updateComponent中，调用我们将要设计的合并state方法。 1234567891011121314151617181920212223242526class FeactCompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; // 其他都一样 const nextState = this._processPendingState(); // 其他都一样 &#125; _processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; nextState = Object.assign(nextState, this._pendingPartialState[i]); &#125; this._pendingPartialState = null; return nextState; &#125;&#125; 其次将批量合并之后的state塞到一次渲染过程中 注意这里的批量操作原理是非常简单的，并不是React中的全部功能。我们主要指出批量操作的原理。 在Feact中，我们只在页面还在渲染的时候，批量合并state，其他时候，我们并不做这样的处理。所以，在updateComponent过程中，我们会做一个标记，告诉外面，我们正在渲染，在渲染结束之后，讲其设置为false。如果setState看到了这个标记为true，他会挂起这个state，但不渲染它。因为它知道，当当前的渲染结束的时候，渲染引擎会重拾这个state进行下一次渲染。 12345678910111213141516171819202122232425262728class FeactCompositeComponent &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; this._rendering = true; // 中间这一部分跟之前一样 this._rendering = false; &#125;;&#125;function FeactComponent() &#123;&#125;FeactComponent.prototype.setState = function (partialState) &#123; const internalInstance = FeactInstanceMap.get(this); internalInstance._pendingPartialState = internalInstance._pendingPartialState || []; internalInstance.push(partialState); if (!internalInstance._rendering) &#123; FeactReconciler.performUpdateIfNecessary(internalInstance); &#125;&#125; 基本上完成啦。 setState陷阱现在，我们已经明白了setState的工作原理以及批量工作的概念，但是这里有几个关于setState的陷阱需要注意。我们知道，当我们利用state去更新组件的时候，有好几个步骤，每个步骤中，被挂起的state需要一个一个的处理，也就是说，当我们在setState中使用this.state是非常危险的 1234componentWillReceiveProps(nextProps) &#123; this.setState(&#123; counter: this.state.counter + 1 &#125;); this.setState(&#123; counter: this.state.counter + 1 &#125;);&#125; 这个例子中，我们期待执行2次加法运算。但是，state会被批量处理，所以第二次setState和第一次的setState有相同的输入，所以，加法运算只会执行一次。 React中，解决这个问题的方法是传入一个回调函数 12345678componentWillReceiveProps(nextProps) &#123; this.setState((currentState) =&gt; (&#123; counter: currentState.counter + 1 &#125;); this.setState((currentState) =&gt; (&#123; counter: currentState.counter + 1 &#125;);&#125; 当传入回调函数的时候，我们将会得到正确的结果，我们将这个特性运用到Feact中去 123456789101112131415161718192021_processPendingState() &#123; const inst = this._instance; if (!this._pendingPartialState) &#123; return inst.state; &#125; let nextState = inst.state; for (let i = 0; i &lt; this._pendingPartialState.length; ++i) &#123; const partialState = this._pendingPartialState[i]; if (typeof partialState === 'function') &#123; nextState = partialState(nextState); &#125; else &#123; nextState = Object.assign(nextState, patialState); &#125; &#125; this._pendingPartialState = null; return nextState;&#125; 至此，大功告成啦！","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React原理（三）更新","date":"2018-03-19T09:08:21.000Z","path":"2018/03/19/React原理（三）更新/","text":"上两篇中，React具有了基本的渲染能力。但是，一旦渲染发生，就不能再改变了。这一篇中，我们将在render中，添加更新功能,并且，将简单的展示虚拟dom的diff过程。 简单更新让React应用实现更新，最普通的办法就是调用组件的setState()方法。但是，React也支持通过React.render()来实现更新。就像如下所示： 12345React.render(&lt;h1&gt;hello&lt;/h1&gt;, root);setTimeout(() =&gt; &#123; React.render(&lt;h1&gt;hello again&lt;/h1&gt;, root);&#125;, 2000) 本篇中，我们暂时忽略setState()，先通过Feact.render()来实现更新。说实话，这就是最屌丝的『props改变，所以更新』的模型，即如果你又render了，并且传入了不同的props给子组件，那么就更新呗。 开始理念非常简单，Feact.render()只需检查，之前是否渲染过，如果渲染过，就执行update。结构如下所示 123456789101112131415161718192021222324252627282930313233343536const Feact = &#123; // 其他都一样 render(element, container) &#123; const prevComponent = getTopLevelComponentInContainer(container); if (prevComponent) &#123; return updateRootComponent( prevComponent, element ); &#125; else &#123; return renderNewRootComponent(element, container); &#125; &#125; // 其他都一样&#125;function renderNewRootComponent(element, container) &#123; // 这个函数就是之前的render内的逻辑 const wrapperElement = Feact.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return FeactReconciler.mountComponent(componentInstance, container);&#125;;function getTopLevelComponentInContainer(container) &#123; // TODO&#125;function updateRootComponent(prevComponent, nextElement) &#123; // TODO&#125; 看起来很美好，如果之前渲染过，则将之前的组件和更新后的组件，传递给一个函数，这个函数将计算出dom所需要做出的更新动作。否则，就像上一篇所讲的那样，直接将组件渲染进来即可。那么，问题已经被降级为搞定我们缺失的2个函数。 记住我们所做的对于每一次渲染，我们需要记录那些我们渲染过的组件，以获取他们的引用，方便后续的渲染。咋整呢？最好的方法就是在创建dom节点的时候，做上一个标记。 123456789101112131415function renderNewRootComponent(element, container) &#123; const wrapperElement = Feact.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); // 注意这里操作 const markUp = FeactReconciler.mountComponent(componentInstance, container); // 多了这么一行，这里将组件的实例保存到container上 // 这里我们想要的是组件实例的_renderedComonent, 因为componentInstance是最顶级的一个壳子，无需更新 // 还记得_renderedComponent么？在上一节的预挂载函数内，我们偷摸的保存了下。 container.__feactComponentInstance = componentInstance._renderedComponent; return markUp;&#125; 那么，对于已经挂在的组件的情况，一样的返回container.__feactComponentInstance。 123function getTopLevelComponentInContainer(container) &#123; return container.__feactComponentInstance;&#125; 更新首先先看一个简单的示例。 123456789101112Feact.render( Feact.createElement('h1', null, 'hello'), root);setTimeout(() =&gt; &#123; Feact.render( Feact.createElement('h1', null, 'hello again'), root );&#125;, 2000); 2秒后，我们又一次调用了Feact.render()，但是，这次调用所传入的元素大概长这样 123456&#123; type: 'h1', props: &#123; children: 'hello again' &#125;&#125; 当Feact确定了这是一个更新动作，则会进入到updateRootComponent()函数中， 1234function updateRootComponet(prevComponet, nextElement) &#123; prevComponent.receiveComponent(nextElement);&#125;; 这里注意，我们没有创建一个新的组件，prevComponent是我们第一次渲染的时候就创建的组件，现在只是更新了它自己而已。所以，组件一旦被创建，它将一直存在，直到被卸载（unmount）。 再来考虑FeactDOMComponent 12345678910111213141516171819202122232425262728class FeactDOMComponent &#123; // 其他都一样 receiveComponent(nextElement) &#123; const prevElement = this._currentElement; this.updateComponent(prevElement, nextElement); &#125; updateComponent(prevElement, nextElement) &#123; const lastProps = prevElement.props; const nextProps = nextElement.props; this._updateDOMProperties(lastProps, nextProps); this._updateDOMChildren(lastProps, nextProps); this._currentElement = nextElement; &#125;; _updateDOMProperties(lastProps, nextProps) &#123; // 更新css &#125; _updateDOMChildren(lastProps, nextProps) &#123; // 更新组件 &#125;&#125; receiveComponent()只是调用了updateComponent()，而updateComponent()则最终调用了_updateDOMProperties()和_updateDOMChildren()，这2个函数最终，完成了真实dom的更新。需要注意的是，_updateDOMProperties()更多的关注了CSS相关的内容。简便期间，我们暂时不考虑它，仅仅指出，在React中，这个函数是用来解决样式的更新的。 _updateDOMChildren()在React中，那可是相当的复杂，主要是解决了各种不同的场景下的执行情况。但是，在Feact中，为了方便理解，我们只考虑子节点是文本的情况，也就是上文中所写的，我们从hello，更新到了hello again。 123456789101112131415161718192021222324252627class FeactDOMComponent &#123; // 其他都一样 _updateDOMChildren(lastProps, nextProps) &#123; const lastContent = lastProps.children; const nextContent = nextProps.children; if (!nextContent) &#123; this.updateTextContent(''); &#125; else if (lastContent !== nextContent) &#123; this.updateTextContent('' + nextContent); &#125; &#125; _updateTextContent(text) &#123; const node = this._hostNode; const firstChild = node.firstChild; if (firstChild &amp;&amp; firstChild === node.lastChild &amp;&amp; firstChild.nodeType ===3) &#123; firstChild.nodeValue = text; return; &#125; node.textContent = text; &#125;&#125; 从上面可以看出，Feact的_updateDOMChildren非常屌丝，但是大概原理就是这样。 更新自定义组件上面这些内容，我们实现了FeactDOMComponent的更新，但是下面这种情况就无能为力了。 123456789101112Feact.render( Feact.createElement(MyCoolComponent, &#123;myProp: 'hello'&#125;), document.getElementById('root'););setTimeout(() =&gt; &#123; Feact.render( Feact.createElement(MyCoolComponent, &#123;myProp: 'hello again'&#125;), document.getElementById('root'); );&#125;, 2000); 更新自定义组件就有趣多了，这也是React的牛逼之处。有一个好消息，自定义组件的更新，归根结底会降级到原生组件的更新，所以上面我们做的工作，都是有效的，没有浪费。 还有个更好的消息，updateRootComponent在执行的时候，并不关心组件是自定义的组件，还是原生的组件。他只是调用receiveComponent，所以，我们需要做的，只是给FeactCompositeComponentWrapper也增加一个receiveComponent就好啦。 1234567891011121314151617181920212223242526272829303132class FeactCompositeComponentWrapper &#123; // 其他都一样 receiveComponent(nextElement) &#123; const prevElement = this._currentElement; this.updateComponent(prevElement, nextElement); &#125; updateComponent(prevComponent, nextElement) &#123; const nextProps = nextElement.props; this._performComponentUpdate(nextElement, nextProps); &#125; _performComponentUpdate(nextElement, nextProps) &#123; this._currentELement = nextElement; const inst = this._instance; inst.props = nextProps; this._updateRenderedComponent(); &#125; _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); prevComponentInstance.receiveComponent(nextRenderedElement); &#125;&#125; 这里有点点复杂，但是也解决了很多问题，而且，React中，基本跟我们写的一样，一样的在ReactCompositeComponentWrapper有上面我们写的4个函数。 最终，这些一系列复杂的更新操作，都会降级到去render一系列的props，然后，把得到的结果传递给_renderedComponent进行更新。_renderedComponent会变成下一个FeactCompositeComponentWrapper或者FeactDOMComponent。 使用协调器挂载组件当然要通过我们之前所写的FeactReconciler，虽然这个操作对于Feact没什么意义，但是我们还是保持和React一致。 123456789101112131415161718192021222324252627282930const FeactReconciler = &#123; // 其他都一样 receiveComponent(internalInstance, nextElement) &#123; internalInstance.receiveComponent(nextElement); &#125;&#125;function updateRootComponentprevComponent, nextElement) &#123; FeactReconciler.receiveComponent(prevComponent, nextElement);&#125;class FeactCompositeComponentWrapper &#123; // 其他都一样 _updateRenderedComponent() &#123; const prevComponentInstance = this._renderedComponent; const inst = this._instance; const nextRenderedElement = inst.render(); FeactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement ); &#125;&#125; 生命周期shouldComponentUpdate和componentWillReceiveProps1234567891011121314151617181920212223class FeactCompompositeComponentWrapper &#123; // 其他都一样 updateComponent(prevElement, nextElement) &#123; const nextProps = nextElement.props; const inst = this._instance; if (inst.componentWillReceiveProps) &#123; inst.componentWillReceiveProps(nextProps); &#125; let shouldUpdate = inst.shouldComponentUpdate(nextProps); if (shouldUpdate) &#123; this._performComponentUpdate(nextElement, nextProps); &#125; else &#123; // 即使不更新，也要更新下最新的props inst.props = nextProps; &#125; &#125;&#125; 还有个大坑到目前为止，还有个很大的问题不知你们发现了没，那就是现在所有的更新，都是假设更新的时候，都是使用了相同的组件，也就是说，下面这种情况我们可以更新 1234567891011Feact.render(&#123; Feact.createElement(MyCoolComponent, &#123;myProp: 'hi'&#125;), root&#125;);setTimeout(() =&gt; &#123; Feact.render( Feact.createElement(MyCoolComponent, &#123; myProp: 'hi again' &#125;), root );&#125;, 2000) 但是，下面这种情况更新不了 1234567891011Feact.render( Feact.createElement(MyCoolComponent, &#123;myProp: 'hi'&#125;), root);setTimeout(() =&gt; &#123; Feact.render( Feact.createElement(SomeOtherComponent, &#123;someOtherProp: 'hmmm' &#125;), root );&#125;, 2000) 这个例子中，我们传入了一个全新的组件，Feact非常弱智的继续渲染原来的MyCoolComponent，然后把他的props更新为{someOtherProp: &#39;hmmm&#39; }。 正确的做法是告诉它，组件的type已经改变了，不应该再去更新，应该卸载掉MyCoolComponent，然后挂载SomeOtherComponent。 想实现这些，Feact必须做到以下2点： 具有卸载组件的能力（unmount） 通知组件的type已经改变，然后让FeactReconciler执行FeactReconciler.mountComponent，而不是去去执行FeactComponent.receiveComponent 在React中，如果你又一次渲染了相同的组件，那么它会更新。这时候，你不需要定义一个key给你的组件。key仅仅在需要渲染成吨的children的时候，是必要的。如果你忘记了给渲染的子组件增加key，React会给你一堆警告，你最好留意这些警告，因为如果没这些key的话，React在需要更新的时候执行的不是更新，而是卸载掉原来的组件，然后挂载新的。 现在知道什么是虚拟DOM了么在React刚出来的时候，各种吹所谓的虚拟DOM，但是我觉得虚拟DOM并不是真的需要关心的。他仅仅是一些概念而已。真正需要关注的，是prevElement和nextElement，他们一起捕获了每次渲染不同的地方，然后FeactDOMComponent将这些不同的地方挂载到了真实的DOM上。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React原理（二）生命周期","date":"2018-03-15T09:30:55.000Z","path":"2018/03/15/React原理（二）生命周期/","text":"上一篇中，简单的介绍了ReactJs的渲染结构，这里，会对组件的生命周期进行简单的分析。 首先，对createClass()这个函数进行简单的处理。 上一节，createClass()如下所示： 12345678910111213const Feact = &#123; // 其他都一样 createClass (spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype.render = spec.render; return Constructor; &#125;&#125; 从上面可以看出，render()方法仅仅接收了子组件的render方法，这里可以简单处理下，将整个spec挂载到组件的原型上去。让Constructor()能够继承包括componentWillMount等更多的属性和方法。 12345678910111213const Feact = &#123; // 其他都一样 createClass (spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype = Object.assign(Constructor.prototype, spec); return Constructor; &#125;&#125; 接下来，我们开始改造FeactCompositeComponentWrapper对象。 在上一章中，我们记得，FeactCompositeComponentWrapper的mountComponent()方法走了个『捷径』，疯狂递归子组件的render方法，直到出现一个原生的dom对象为止。现在有一个问题，循环的过程中，这个『捷径』仅仅调用了子组件的render()方法，而生命周期函数却无处安放。 1234567891011121314151617181920class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentELement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === 'function') &#123; element = (new element.type(element.props)).render(); &#125; const domComponentInstance = new FeactDomComponent(element); domComponentInstance.mountComponent(container); &#125;&#125; 从上面可以看出，mountComponent逐步向下，直到找到原生的组件。只要render()返回了一个自定义组件，他就会继续调用render()，直到得到一个原生的组件。这就导致了，这些子组件，没有办法参与到整个挂载的生命周期中去。换句话说，它们的render()方法是被调用了，但是也就是仅仅被调用了而已。现在，我们需要做的事情，就是将每一个完整组件参与到整个挂载过程中。 现在，开始改造下FeactCompositeComponentWrapper对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentELement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); // let element = componentInstance.render(); // while (typeof element.type === 'function') &#123; // element = (new element.type(element.props)).render(); // &#125; this._instance = componentInstance; const markup = this.performInitialMount(container); return markup; // const domComponentInstance = new FeactDomComponent(element); // domComponentInstance.mountComponent(container); &#125; performInitialMount(container) &#123; const renderedElement = this._instance.render(); const child = instantiateFeactComponent(renderedElement); // 这一行暂时没用，以后将负责关于更新相关的操作 this._renderedComponent = child; return FeactReconciler.mountComponent(child, container); &#125;&#125;const FeactReconciler = &#123; mountComponent(internalInstance, container) &#123; return internalInstance.mountComponent(container); &#125;&#125;function instantiateFeactComponent(element) &#123; if (typeof element.type === 'string') &#123; return new FeactDOMComponent(element); &#125; else if (typeof element.type === 'function') &#123; return new FeactCompositeComponentWrapper(element); &#125;&#125; 一下子写了介么多代码，传递了一个基本的思想，就是将mounting的过程，单独提出来。也就是FeactReconciler的作用，它将在以后承担更多的工作。在React中，也存在一个ReactReconciler，跟我们的FeactReconciler一样。 处理 Feact.render()Feact.render()在上一章中，调用了componentInstance.mountComponent(container)，现在，讲其更新为我们的刚刚写的FeactReconciler 123456789101112const Feact = &#123; // 其他都一样 render(element, container) &#123; const warpperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return FeactReconciler.mountComponent( componentInstance, container ); &#125;&#125; 至此，所有的自定义组件，已经被完全挂载，这些自定义组件将参与到整个挂载的生命周期中去。 最后，增加componentWillMount和componentDidMount 接下来就简单啦，增加钩子函数即可。 1234567891011121314151617181920212223242526class FeactCompositeComponentWrapper &#123; // 其他都一样 mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); this._instance = componentInstance; if (componentInstance.componentWillMount) &#123; componentInstance.componentWillMount(); &#125; const markUp = this.performInitialMount(container); if (componentInstance.componentDidMount) &#123; componentInstance.componentDidMount(); &#125; return markUp; &#125;, // 其他都一样&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React原理（一）渲染","date":"2017-10-19T09:37:55.000Z","path":"2017/10/19/React原理（一）渲染/","text":"React是声明式的在React中，写一个组件，通常会这么写12345class Mycomponent extends React.Component &#123; render () &#123; return &lt;div&gt;hello&lt;/div&gt; &#125;&#125; 其中，return的内容，会被编译为12345class Mycomponent extends React.Component &#123; render () &#123; return React.createElement('div', null, 'hello'); &#125;&#125; 在某种意义上说，我们是通过调用了React.createElement来创建一个组件。但是，事实上我们仅仅是声明了这个组件，然后React帮助我们实例化了这个组件对象，并调用render()来创建了这个组件。我们仅仅需要描述我们需要什么，剩下的全部由React渲染页面。 React的渲染基础渲染原理接下来，靠着这个思想，来创建一个假的React，这里暂且叫它为Feact吧。 首先，要实现React，我们分解问题来看，就是要实现一个 1Feact.render(&lt;h1&gt;hello world&lt;/h1&gt;, document.getElementById('root')); 简单了解React就会知道，render()方法的第一个参数，是jsx语法，这里暂时不考虑jsx的编译，问题继续被降级，那么就是要实现一个 1234Feact.render( Feact.createElement('h1', null, 'hello world'), document.getElementById('root')); 也就是说，Feact对象中，目前必须得有2个方法，一个是createElement(), 一个是render()。其中，createElement()方法返回一个普通的json对象，来描述dom。所以，目前，我们的Feact对象应该张这个样子 1234567891011121314151617const Feact = &#123; createElement(type, props, children) &#123; const element = &#123; type, props: props || &#123;&#125; &#125;; if (children) &#123; element.props.children = children; &#125; return element; &#125; render() &#123; &#125;&#125; 那么render函数，从上面可以得知，render()接收两个参数，一个是描述dom的对象，一个是被插入的位置。也就是说render()应该长的像这样子 1234render(element, container) &#123; const componentInstance = new FeactDomComponent(element); return componentInstance.mountComponent(container);&#125; 其中，FeactDomComponent对象用来生成dom，然后调用该对象中的mountComponent方法来实现挂载。所以FeactDomComponent对象至少应该是这个样子 123456789101112131415161718192021class FeactDomComponent &#123; /* element 即为描述dom的json对象 */ constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; const domElement = document.createElement(this._currentElement.type); const text = this._currentElement.props.text; const textNode = document.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); // 这里暂时没啥用，后面更新的时候会用到 this._hostNode = domElement; return domElement; &#125; &#125; 给以上代码组装下，一个最基本的Feact就组件完成了。 用户自定义组件以上得到的仅仅是一个写死的组件，下面加入用户可配置功能。所以，Feact需要添加一个createClass()方法。 123456789101112131415161718192021222324252627282930313233const Feact = &#123; createElement() &#123; /* 跟上头一样 */ &#125; createClass(spec) &#123; function Constructor(props) &#123; this.props = props; &#125; Constructor.prototype.render = spec.render; return Constructor; &#125; render(element, container) &#123; // 之前的render不能接收用户自定义的组件，这里待会儿修改 &#125; &#125;;const MyTitle = Feact.createClass(&#123; render() &#123; return Feact.createElement('h1', null, this.props.message); &#125;&#125;);Feact.render(&#123; Feact.createElement(MyTitle, &#123; message: 'i am here' &#125;), document.getElementById('root')&#125;); 现在，可以Feact可以接收自定义的组件了。就差改写render()方法了。但是，目前来看，render()方法利用FeactDomComponent对象仅仅处理原生的dom。需要进行改造，添加一个FeactCompositeComponentWrapper来包裹FeactDomComponent对象 12345678910111213141516171819202122render(element, container) &#123; const componentInstance = new FeactCompositeComponentWrapper(element); return componentInstance.mountComponent(container);&#125;class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentElement = element; &#125; mountComponent(container) &#123; /* 目前Component是一个构造函数 */ const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); const element = componentInstance.render(); const domComponentInstance = new FeactDOMComponent(element); return domComponentInstance.mountComponent(container); &#125;&#125; 到目前为止，Feact已经能处理一些用户自定义的组件以及原生组件，但是在render()方法中，假如存在自定义组件嵌套的话，目前还不能胜任，比如一个组件如下所示，MyMessage嵌套了Mytitle： 1234567891011const MyMessage = Feact.createClass(&#123; render() &#123; if (this.props.asTitle) &#123; return Feact.createElement(Mytitle, &#123; message: this.props.message &#125;); &#125; else &#123; return Feact.createElement('p', null, this.props.message) &#125; &#125;&#125;); 这样的话，我们必须在FeactCompositeComponentWrapper中的mountComponent方法里，做一些简单的逻辑判断。那么，FeactCompositeComponentWrapper改写为： 123456789101112131415161718class FeactCompositeComponentWrapper &#123; constructor(element) &#123; this._currentELement = element; &#125; mountComponent(container) &#123; const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === 'function') &#123; element = (new element.type(element.props)).render(); &#125; const domComponentInstance = new FeactDomComponent(element); domComponentInstance.mountComponent(container); &#125;&#125; 目前来看，Feact已经更加完善了，但是目前的生命周期还有问题，后续再解决。另外，在Feact.render()执行的时候，无论组件是自定义组件还是原生的dom，我们发现他们终归会执行到FeactDOMComponent，所以这里为了统一处理，我们可以给所有的组件包裹一个工厂函数，让他成为自定义组件，方便我们后续处理。 工厂函数很简单，如下所示 123456789101112131415const TopLevelWrapper = function (props) &#123; this.props = props;&#125;TopLevelWrapper.prototype.render = function () &#123; return this.props;&#125;const Feact = &#123; render(element, container) &#123; const warpperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); return componentInstance.mountComponent(container); &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"诚惶诚恐","date":"2017-04-18T07:35:26.000Z","path":"2017/04/18/诚惶诚恐/","text":"新的开始，希望一切步入正轨。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Flex布局","date":"2017-03-05T11:42:24.000Z","path":"2017/03/05/Flex布局/","text":"父级元素设置display为flex或者inline-flex时，表示该元素将以弹性盒子方式布局。同时，该元素上的float、clear、vertical-align将全部失效。 123.box &#123; display: flex; /*inline-flex*/&#125; 基本概念： flex容器: 设置display为flex的父级元素为flex容器 flex项目: 容器中所有的子元素，为容器的flex项目，即flex item 主轴(main asix): flex项目的填充方向，默认为水平方向；主轴的起始位置(flex容器边框的交叉点)为main start，结束位置为main end 交叉轴(cross asix): 与主轴垂直交叉的轴，叫交叉轴 ；交叉轴的起始位置为cross start，结束位置为cross end 主轴空间: flex项目占据的主轴空间为main size；占据的交叉轴空间为cross size flex容器接收的属性：123456789.box &#123; display: flex; /*inline-flex*/ flex-direction: row; /*主轴的方向，默认row(从左到右)，可选row-reverse(从右到左)、column(从上到下)、column-reverse(从下到上)*/ flex-wrap: nowrap; /*是否换行，默认nowrap(不换行)，可选wrap(换行，第一行在上方)、wrap-reverse(换行，第一行在下方)*/ flex-flow: row nowrap; /*flex-direction和flex-wrap的连写*/ justiy-content: flex-start; /*容器内的项目在主轴上的对齐方式，默认flex-start(左对齐)，可选flex-end(右对齐)、center(居中)、space-between(两端对齐，左侧的去最左右侧去最右，项目间隔相等)、space-around(左右间隔平分)*/ align-items: stretch; /*容器内的项目在交叉轴上的对齐方式，默认stretch(拉伸，如果没设置高度，则垂直填充)，可选默认flex-start(上对齐)、flex-end(下对齐)、center(居中)、baseline(第一行文字下对齐对齐，即文字大小不同时，以文字下基线对齐)*/ align-content: stretch; /*多轴线对齐方式(多行)，如果只有一根轴线(单行)，则无效，可选flex-start、flex-end、center、space-between、space-around*/&#125; flex项目接收的属性：12345678.box &gt; .item &#123; order: 0; /*排序，越小越靠前，默认为0*/ flex-grow: 0; /*分配剩余空间的比例，默认为0，有剩余空间也不分配*/ flex-shrink: 1; /*缩小比例，如果容器空间不足，则按比例缩小，默认为1，如果为0则不缩小*/ flex-basis: auto; /*分配空间前，项目占据的主轴大小，默认为auto，即为项目本身的大小*/ flex: 0 1 auto; /*flex-grow, flex-shrink, flex-basis的连写*/ align-self: auto; /*允许单个项目与其他不一样的交叉轴对齐方式，默认auto为继承父元素的align-items*/&#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://yoursite.com/tags/flex/"}]},{"title":"新的开始","date":"2016-12-15T14:48:22.000Z","path":"2016/12/15/new-start/","text":"妈的，这是天意么？之前的github帐号莫名其妙的被封了，申诉无数次无果，一怒之下删除了帐号。 思来想去，彩笔到底是离不开这个网站，不要脸的又注册了一个。 就当新的开始把，在苦逼的2016结束之际，希望能有更崭新的一面。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]